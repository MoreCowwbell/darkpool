{
 "cells": [
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# Cell 0 - Accumulation Signal Sandbox\n",
    "Explore alternate short-signal formulas using daily_metrics data (read-only). No database writes."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "1a68c6b0",
   "metadata": {},
   "outputs": [],
   "source": "# Cell 1 - Imports and Configuration\nfrom pathlib import Path\nimport sys\n\nimport duckdb\nimport numpy as np\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Find project root (darkpool/) from Special_tools/ location\nnotebook_dir = Path.cwd()\nif notebook_dir.name == 'Special_tools':\n    project_root = notebook_dir.parent\nelif (notebook_dir / 'darkpool_analysis').exists():\n    project_root = notebook_dir\nelse:\n    # Walk up to find darkpool_analysis\n    project_root = notebook_dir\n    for _ in range(5):\n        if (project_root / 'darkpool_analysis').exists():\n            break\n        project_root = project_root.parent\n\nif (project_root / 'darkpool_analysis').exists():\n    sys.path.insert(0, str(project_root))\n\nfrom darkpool_analysis.config import load_config\n\nconfig = load_config()\n\n# =============================================================================\n# USER CONFIGURATION\n# =============================================================================\n\nTICKER = 'XLF'\nSTART_DATE = '2025-10-01'\nEND_DATE = '2026-01-05'\nDB_PATH = config.db_path\n\nDOT_MODE = 'current'  # 'current', 'option_a', 'option_b', 'all'\nBLEND_SHORT_WEIGHT = 0.6\nBLEND_FLOW_WEIGHT = 0.4\n\n# Median-threshold settings\nTHRESHOLD_K = 1.5\n\n# =============================================================================\n# EXPERIMENT DOT COLORS - Edit these to customize signal marker colors\n# =============================================================================\n# Each experiment can have separate colors for accumulation (buy) and distribution (sell) signals\n# Format: {'buy': <color>, 'sell': <color>}\n# Available colors: '#00ff88' (green), '#ff6b6b' (red), '#4aa3ff' (blue), \n#                   '#ffd700' (yellow), '#00d4ff' (cyan), '#b026ff' (purple), '#ff9f43' (orange)\n\nEXPERIMENT_DOT_COLORS = {\n    'A': {'buy': \"#00ffd5\", 'sell': '#00ffd5'},      # Cyan for both (VWBR)\n    'B': {'buy': \"#ffe600\", 'sell': '#ffe600'},      # Yellow for both (Short B/S Ratio - baseline)\n    'C': {'buy': \"#ff7b00\", 'sell': '#ff7b00'},      # Orange for both (Combined)\n    'D': {'buy': \"#1eff00\", 'sell': '#1eff00'},      # Green for both (Imbalance)\n    'Mean': {'buy': \"#ffffff\", 'sell': '#ff6b6b'},   # White/Red for Mean consensus signals\n}\n\n# =============================================================================\n# OHLC DOT DISPLAY MODE - Controls which experiment dots appear on OHLC chart\n# =============================================================================\n# Options:\n#   'ALL'  - Show dots from all 4 experiments (vertically stacked)\n#   'A'    - Show only Score A (VWBR) dots\n#   'B'    - Show only Score B (Short B/S Ratio) dots\n#   'C'    - Show only Score C (Combined) dots\n#   'D'    - Show only Score D (Imbalance) dots\n#   'Mean' - Show single dot only if 3+ experiments agree (consensus signal)\n#   'None' - Hide all dots on OHLC chart\nOHLC_DOT_DISPLAY = 'ALL'"
  },
  {
   "cell_type": "code",
   "execution_count": 30,
   "id": "e4be1b04",
   "metadata": {},
   "outputs": [],
   "source": [
    "# Cell 2 - Styling Constants and Helper Functions\n",
    "import matplotlib.dates as mdates\n",
    "from scipy.interpolate import PchipInterpolator\n",
    "\n",
    "COLORS = {\n",
    "    'background': '#0f0f10',\n",
    "    'panel_bg': '#141416',\n",
    "    'text': '#e6e6e6',\n",
    "    'grid': '#2a2a2d',\n",
    "    'white': '#ffffff',\n",
    "    'green': '#00ff88',\n",
    "    'red': '#ff6b6b',\n",
    "    'yellow': '#ffd700',\n",
    "    'cyan': '#00d4ff',\n",
    "    'orange': '#ff9f43',\n",
    "    'purple': '#b026ff',\n",
    "    'neutral': '#6b6b6b',\n",
    "    'blue': '#4aa3ff',\n",
    "}\n",
    "GRID_ALPHA = 0.18\n",
    "OHLC_LINE_WIDTH = 1.2\n",
    "SIGNAL_MARKER_SIZE = 60\n",
    "SIGNAL_EDGE_WIDTH = 0.6\n",
    "MAIN_LINE_WIDTH = 2.3\n",
    "MARKER_SIZE = 25\n",
    "\n",
    "def _apply_axis_style(ax):\n",
    "    ax.set_facecolor(COLORS['panel_bg'])\n",
    "    ax.tick_params(colors=COLORS['text'], labelsize=9)\n",
    "    ax.spines['top'].set_visible(False)\n",
    "    ax.spines['right'].set_visible(False)\n",
    "    ax.spines['left'].set_color(COLORS['grid'])\n",
    "    ax.spines['bottom'].set_color(COLORS['grid'])\n",
    "    ax.grid(True, alpha=GRID_ALPHA, color=COLORS['grid'], linestyle='--')\n",
    "\n",
    "def _format_volume(value):\n",
    "    if pd.isna(value):\n",
    "        return 'NA'\n",
    "    value = float(value)\n",
    "    if abs(value) >= 1_000_000_000:\n",
    "        return f'{value / 1_000_000_000:.1f}B'\n",
    "    if abs(value) >= 1_000_000:\n",
    "        return f'{value / 1_000_000:.1f}M'\n",
    "    if abs(value) >= 1_000:\n",
    "        return f'{value / 1_000:.0f}K'\n",
    "    return f'{value:,.0f}'\n",
    "\n",
    "def _rolling_zscore(series, window, min_periods):\n",
    "    \"\"\"Compute rolling z-score with safe division.\"\"\"\n",
    "    rolling = series.rolling(window=window, min_periods=min_periods)\n",
    "    mean = rolling.mean()\n",
    "    std = rolling.std(ddof=0)\n",
    "    # Avoid division by zero: replace 0 std with NaN\n",
    "    std = std.replace(0, np.nan)\n",
    "    return (series - mean) / std\n",
    "\n",
    "def _sigmoid(x):\n",
    "    return 1.0 / (1.0 + np.exp(-x))\n",
    "\n",
    "def _compute_score_display(short_z, lit_z, price_z, otc_z, cfg):\n",
    "    short = pd.to_numeric(short_z, errors='coerce').to_numpy(dtype=float)\n",
    "    lit = pd.to_numeric(lit_z, errors='coerce').fillna(0.0).to_numpy(dtype=float)\n",
    "    price = pd.to_numeric(price_z, errors='coerce').fillna(0.0).to_numpy(dtype=float)\n",
    "    otc = pd.to_numeric(otc_z, errors='coerce').fillna(0.0).to_numpy(dtype=float)\n",
    "\n",
    "    score = np.full_like(short, np.nan, dtype=float)\n",
    "    valid = ~np.isnan(short)\n",
    "    if valid.any():\n",
    "        raw = (\n",
    "            cfg.composite_w_short * np.tanh(short[valid] * 0.5)\n",
    "            + cfg.composite_w_lit * np.tanh(lit[valid] * 0.5)\n",
    "            + cfg.composite_w_price * np.tanh(price[valid] * 0.3)\n",
    "        )\n",
    "        intensity_range = cfg.intensity_scale_max - cfg.intensity_scale_min\n",
    "        intensity = cfg.intensity_scale_min + intensity_range * _sigmoid(otc[valid])\n",
    "        score[valid] = np.clip(raw * intensity, -1.0, 1.0)\n",
    "\n",
    "    display = (score + 1.0) * 50.0\n",
    "    return pd.Series(display, index=short_z.index)\n",
    "\n",
    "def _plot_smooth_line(ax, x_values, values, color, valid_mask, linewidth=MAIN_LINE_WIDTH, alpha=0.85, zorder=3):\n",
    "    \"\"\"Plot a smooth PCHIP-interpolated line through valid data points.\"\"\"\n",
    "    if valid_mask.sum() >= 3:\n",
    "        valid_x = x_values[valid_mask]\n",
    "        valid_values = values[valid_mask]\n",
    "\n",
    "        x_nums = np.asarray(valid_x, dtype=float)\n",
    "        x_smooth = np.linspace(x_nums.min(), x_nums.max(), 150)\n",
    "        interp = PchipInterpolator(x_nums, valid_values.to_numpy() if hasattr(valid_values, 'to_numpy') else np.asarray(valid_values))\n",
    "        y_smooth = interp(x_smooth)\n",
    "\n",
    "        ax.plot(\n",
    "            x_smooth,\n",
    "            y_smooth,\n",
    "            color=color,\n",
    "            linewidth=linewidth,\n",
    "            alpha=alpha,\n",
    "            zorder=zorder,\n",
    "        )\n",
    "    else:\n",
    "        ax.plot(\n",
    "            x_values[valid_mask],\n",
    "            values[valid_mask],\n",
    "            color=color,\n",
    "            linewidth=linewidth,\n",
    "            alpha=alpha,\n",
    "            zorder=zorder,\n",
    "        )\n",
    "\n",
    "def _set_flow_axis(ax, values):\n",
    "    series = pd.to_numeric(values, errors='coerce')\n",
    "    max_abs = series.abs().max(skipna=True)\n",
    "    if pd.isna(max_abs) or max_abs == 0:\n",
    "        max_abs = 1.0\n",
    "    padding = max(max_abs * 0.1, 1.0)\n",
    "    y_max = max_abs + padding\n",
    "    y_min = -y_max\n",
    "    ax.set_ylim(y_min, y_max)\n",
    "    ax.set_yticks(np.linspace(y_min, y_max, 5))\n",
    "    ax.yaxis.set_major_formatter(plt.FuncFormatter(lambda x, p: _format_volume(x)))\n",
    "    ax.axhline(0.0, color=COLORS['neutral'], linestyle='--', linewidth=1.2, alpha=0.7)\n",
    "\n",
    "def _set_ratio_axis(ax, values):\n",
    "    series = pd.to_numeric(values, errors='coerce')\n",
    "    max_val = series.max(skipna=True)\n",
    "    if pd.isna(max_val):\n",
    "        max_val = 2.0\n",
    "    upper = max(2.0, float(max_val) * 1.1)\n",
    "    ax.set_ylim(0, upper)\n",
    "\n",
    "def _set_volume_axis(ax, values):\n",
    "    series = pd.to_numeric(values, errors='coerce')\n",
    "    max_val = series.max(skipna=True)\n",
    "    if pd.isna(max_val) or max_val <= 0:\n",
    "        max_val = 1.0\n",
    "    y_max = max_val * 1.1\n",
    "    ax.set_ylim(0, y_max)\n",
    "    ax.set_yticks(np.linspace(0, y_max, 5))\n",
    "    ax.yaxis.set_major_formatter(plt.FuncFormatter(lambda x, p: _format_volume(x)))\n",
    "\n",
    "def _add_median_thresholds(ax, series, k=1.5, center_override=None):\n",
    "    values = pd.to_numeric(series, errors='coerce').dropna()\n",
    "    if values.empty:\n",
    "        return None, None, None\n",
    "    center = float(center_override) if center_override is not None else float(values.median())\n",
    "    deviations = (values - center).abs()\n",
    "    mad = deviations.median()\n",
    "    ax.axhline(center, color=COLORS['neutral'], linestyle='--', linewidth=1.0, alpha=0.7)\n",
    "    ax.text(0.99, center, 'median', transform=ax.get_yaxis_transform(), ha='right', va='bottom', fontsize=7, color=COLORS['neutral'])\n",
    "    if pd.isna(mad) or mad == 0:\n",
    "        return center, None, None\n",
    "    spread = mad * k\n",
    "    buy = center + spread\n",
    "    sell = center - spread\n",
    "    ax.axhline(buy, color=COLORS['green'], linestyle='--', linewidth=1.0, alpha=0.6)\n",
    "    ax.axhline(sell, color=COLORS['red'], linestyle='--', linewidth=1.0, alpha=0.6)\n",
    "    return center, buy, sell\n",
    "\n",
    "DOT_SPECS = {\n",
    "    'current': {'accum': COLORS['green'], 'dist': COLORS['red'], 'offset': -0.18},\n",
    "    'option_a': {'accum': COLORS['blue'], 'dist': COLORS['purple'], 'offset': 0.0},\n",
    "    'option_b': {'accum': COLORS['yellow'], 'dist': COLORS['orange'], 'offset': 0.18},\n",
    "}\n",
    "\n",
    "def _plot_ohlc_bars(ax, df_ohlc, x_indices):\n",
    "    \"\"\"Plot OHLC bars matching plotter_chart.py style.\"\"\"\n",
    "    bar_width = 0.6\n",
    "    half_width = bar_width / 2\n",
    "\n",
    "    for xi, (_, row) in zip(x_indices, df_ohlc.iterrows()):\n",
    "        open_ = row['open']\n",
    "        high = row['high']\n",
    "        low = row['low']\n",
    "        close = row['close']\n",
    "        if pd.isna(open_) or pd.isna(close) or pd.isna(high) or pd.isna(low):\n",
    "            continue\n",
    "        color = COLORS['blue'] if close >= open_ else COLORS['orange']\n",
    "        ax.vlines(xi, low, high, color=color, linewidth=OHLC_LINE_WIDTH, zorder=3)\n",
    "        ax.hlines(open_, xi - half_width, xi, color=color, linewidth=OHLC_LINE_WIDTH, zorder=3)\n",
    "        ax.hlines(close, xi, xi + half_width, color=color, linewidth=OHLC_LINE_WIDTH, zorder=3)\n",
    "\n",
    "def _plot_ohlc_signal_markers(ax, df_ohlc, scores, x_indices, offset):\n",
    "    \"\"\"Plot accumulation/distribution markers on OHLC chart.\"\"\"\n",
    "    if scores.isna().all():\n",
    "        return\n",
    "\n",
    "    buy_mask = scores >= 70\n",
    "    sell_mask = scores <= 30\n",
    "    if buy_mask.any():\n",
    "        ax.scatter(\n",
    "            x_indices[buy_mask],\n",
    "            df_ohlc.loc[buy_mask, 'low'] - offset,\n",
    "            s=SIGNAL_MARKER_SIZE,\n",
    "            c=COLORS['green'],\n",
    "                edgecolors='none',\n",
    "            linewidths=SIGNAL_EDGE_WIDTH,\n",
    "            zorder=6,\n",
    "        )\n",
    "    if sell_mask.any():\n",
    "        ax.scatter(\n",
    "            x_indices[sell_mask],\n",
    "            df_ohlc.loc[sell_mask, 'high'] + offset,\n",
    "            s=SIGNAL_MARKER_SIZE,\n",
    "            c=COLORS['red'],\n",
    "                edgecolors='none',\n",
    "            linewidths=SIGNAL_EDGE_WIDTH,\n",
    "            zorder=6,\n",
    "        )\n",
    "\n",
    "def _plot_score_panel(ax, x, scores, confidence, title, dot_mode, dot_sources, force_self_dots=False, dot_accum_color=None, dot_dist_color=None):\n",
    "    from matplotlib.colors import LinearSegmentedColormap\n",
    "\n",
    "    score_cmap = LinearSegmentedColormap.from_list(\n",
    "        'score_cmap',\n",
    "        [\n",
    "            (0.0, COLORS['purple']),\n",
    "            (0.5, '#555555'),\n",
    "            (1.0, COLORS['green']),\n",
    "        ],\n",
    "    )\n",
    "\n",
    "    scores_filled = scores.fillna(50)\n",
    "    conf_filled = confidence.fillna(0.5)\n",
    "\n",
    "    for xi, score, conf, score_raw in zip(x, scores_filled, conf_filled, scores):\n",
    "        norm_score = np.clip(score / 100.0, 0, 1)\n",
    "        dev = norm_score - 0.5\n",
    "        norm_score = 0.5 + np.sign(dev) * (abs(dev) ** 0.85)\n",
    "        norm_score = np.clip(norm_score, 0, 1)\n",
    "        bar_color = score_cmap(norm_score)\n",
    "        alpha = 0.8 if conf >= 0.6 else 0.4\n",
    "        bar_height = score / 100.0\n",
    "        ax.bar(xi, bar_height, bottom=0, color=bar_color, alpha=alpha, width=0.72, zorder=2)\n",
    "\n",
    "        if not pd.isna(score_raw):\n",
    "            label_y = max(bar_height / 2, 0.12)\n",
    "            ax.text(\n",
    "                xi,\n",
    "                label_y,\n",
    "                f'{score:.0f}',\n",
    "                ha='center',\n",
    "                va='center',\n",
    "                fontsize=7,\n",
    "                color=COLORS['white'],\n",
    "                zorder=4,\n",
    "            )\n",
    "\n",
    "\n",
    "        conf_height = 0.08 * conf\n",
    "        if conf >= 0.7:\n",
    "            conf_color = COLORS['green']\n",
    "        elif conf >= 0.4:\n",
    "            conf_color = COLORS['yellow']\n",
    "        else:\n",
    "            conf_color = COLORS['red']\n",
    "        ax.bar(xi, conf_height, bottom=-0.12, color=conf_color, alpha=0.6, width=0.54, zorder=3)\n",
    "\n",
    "    ax.axhline(y=0.30, color=COLORS['red'], linestyle='--', linewidth=0.8, alpha=0.4, zorder=1)\n",
    "    ax.axhline(y=0.50, color=COLORS['neutral'], linestyle='--', linewidth=0.8, alpha=0.4, zorder=1)\n",
    "    ax.axhline(y=0.70, color=COLORS['green'], linestyle='--', linewidth=0.8, alpha=0.4, zorder=1)\n",
    "    ax.set_ylim(-0.15, 1.08)\n",
    "    ax.set_yticks([0, 0.3, 0.5, 0.7, 1.0])\n",
    "    ax.set_yticklabels(['0', '30', '50', '70', '100'])\n",
    "    ax.set_title(title, color=COLORS['text'], fontsize=10, fontweight='bold', loc='left')\n",
    "\n",
    "    dot_mode = dot_mode or 'current'\n",
    "    if dot_mode == 'all':\n",
    "        dot_keys = ['current', 'option_a', 'option_b']\n",
    "    else:\n",
    "        dot_keys = [dot_mode]\n",
    "\n",
    "    dot_pad = 0.07\n",
    "    # Use custom colors if provided, otherwise default to green/red\n",
    "    accum_color = dot_accum_color if dot_accum_color else COLORS['green']\n",
    "    dist_color = dot_dist_color if dot_dist_color else COLORS['red']\n",
    "\n",
    "    if force_self_dots:\n",
    "        series = pd.to_numeric(scores, errors='coerce')\n",
    "        accum_mask = (series >= 70).to_numpy()\n",
    "        dist_mask = (series <= 30).to_numpy()\n",
    "        if accum_mask.any():\n",
    "            y_vals = (series[accum_mask] / 100.0) + dot_pad\n",
    "            y_vals = np.minimum(y_vals, 1.04)\n",
    "            ax.scatter(\n",
    "                x[accum_mask],\n",
    "                y_vals.to_numpy(),\n",
    "                s=60,\n",
    "                c=accum_color,\n",
    "                edgecolors='none',\n",
    "                linewidths=0.0,\n",
    "                zorder=6,\n",
    "            )\n",
    "        if dist_mask.any():\n",
    "            y_vals = (series[dist_mask] / 100.0) + dot_pad\n",
    "            y_vals = np.minimum(y_vals, 1.04)\n",
    "            ax.scatter(\n",
    "                x[dist_mask],\n",
    "                y_vals.to_numpy(),\n",
    "                s=60,\n",
    "                c=dist_color,\n",
    "                edgecolors='none',\n",
    "                linewidths=0.0,\n",
    "                zorder=6,\n",
    "            )\n",
    "        return\n",
    "    for key in dot_keys:\n",
    "        series = dot_sources.get(key)\n",
    "        if series is None:\n",
    "            continue\n",
    "        series = pd.to_numeric(series, errors='coerce')\n",
    "        spec = DOT_SPECS.get(key, DOT_SPECS['current'])\n",
    "        offset = spec['offset'] if dot_mode == 'all' else 0.0\n",
    "        accum_mask = (series >= 70).to_numpy()\n",
    "        dist_mask = (series <= 30).to_numpy()\n",
    "        if accum_mask.any():\n",
    "            y_vals = (series[accum_mask] / 100.0) + dot_pad\n",
    "            y_vals = np.minimum(y_vals, 1.04)\n",
    "            ax.scatter(\n",
    "                x[accum_mask] + offset,\n",
    "                y_vals.to_numpy(),\n",
    "                s=60,\n",
    "                c=spec['accum'],\n",
    "                edgecolors='none',\n",
    "                linewidths=0.0,\n",
    "                zorder=6,\n",
    "            )\n",
    "        if dist_mask.any():\n",
    "            y_vals = (series[dist_mask] / 100.0) + dot_pad\n",
    "            y_vals = np.minimum(y_vals, 1.04)\n",
    "            ax.scatter(\n",
    "                x[dist_mask] + offset,\n",
    "                y_vals.to_numpy(),\n",
    "                s=60,\n",
    "                c=spec['dist'],\n",
    "                edgecolors='none',\n",
    "                linewidths=0.0,\n",
    "                zorder=6,\n",
    "            )"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 31,
   "id": "e9f5a3f4",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Loaded 61 rows for XLF\n"
     ]
    },
    {
     "data": {
      "text/html": [
       "<div>\n",
       "<style scoped>\n",
       "    .dataframe tbody tr th:only-of-type {\n",
       "        vertical-align: middle;\n",
       "    }\n",
       "\n",
       "    .dataframe tbody tr th {\n",
       "        vertical-align: top;\n",
       "    }\n",
       "\n",
       "    .dataframe thead th {\n",
       "        text-align: right;\n",
       "    }\n",
       "</style>\n",
       "<table border=\"1\" class=\"dataframe\">\n",
       "  <thead>\n",
       "    <tr style=\"text-align: right;\">\n",
       "      <th></th>\n",
       "      <th>date</th>\n",
       "      <th>symbol</th>\n",
       "      <th>finra_buy_volume</th>\n",
       "      <th>short_sell_volume</th>\n",
       "      <th>short_buy_sell_ratio</th>\n",
       "      <th>short_buy_sell_ratio_z</th>\n",
       "      <th>finra_buy_volume_z</th>\n",
       "      <th>lit_buy_volume</th>\n",
       "      <th>lit_sell_volume</th>\n",
       "      <th>lit_buy_ratio</th>\n",
       "      <th>...</th>\n",
       "      <th>volume</th>\n",
       "      <th>combined_ratio</th>\n",
       "      <th>vw_flow</th>\n",
       "      <th>lit_buy_sell_ratio</th>\n",
       "      <th>vw_flow_z</th>\n",
       "      <th>acc_score_a</th>\n",
       "      <th>acc_score_b</th>\n",
       "      <th>acc_score_c</th>\n",
       "      <th>imbalance_signal</th>\n",
       "      <th>acc_score_d</th>\n",
       "    </tr>\n",
       "  </thead>\n",
       "  <tbody>\n",
       "    <tr>\n",
       "      <th>0</th>\n",
       "      <td>2025-10-08</td>\n",
       "      <td>XLF</td>\n",
       "      <td>3449111.0</td>\n",
       "      <td>3193260.0</td>\n",
       "      <td>1.080122</td>\n",
       "      <td>NaN</td>\n",
       "      <td>NaN</td>\n",
       "      <td>3239895.0</td>\n",
       "      <td>1640153.0</td>\n",
       "      <td>0.663906</td>\n",
       "      <td>...</td>\n",
       "      <td>26848679.0</td>\n",
       "      <td>1.383909</td>\n",
       "      <td>1855593.0</td>\n",
       "      <td>1.975361</td>\n",
       "      <td>NaN</td>\n",
       "      <td>NaN</td>\n",
       "      <td>NaN</td>\n",
       "      <td>50.0</td>\n",
       "      <td>0.605079</td>\n",
       "      <td>NaN</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>1</th>\n",
       "      <td>2025-10-09</td>\n",
       "      <td>XLF</td>\n",
       "      <td>4410866.0</td>\n",
       "      <td>4895667.0</td>\n",
       "      <td>0.900973</td>\n",
       "      <td>NaN</td>\n",
       "      <td>NaN</td>\n",
       "      <td>3608238.0</td>\n",
       "      <td>3521097.0</td>\n",
       "      <td>0.506111</td>\n",
       "      <td>...</td>\n",
       "      <td>33922435.0</td>\n",
       "      <td>0.952754</td>\n",
       "      <td>-397660.0</td>\n",
       "      <td>1.024748</td>\n",
       "      <td>NaN</td>\n",
       "      <td>NaN</td>\n",
       "      <td>NaN</td>\n",
       "      <td>50.0</td>\n",
       "      <td>-0.835889</td>\n",
       "      <td>NaN</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>2</th>\n",
       "      <td>2025-10-10</td>\n",
       "      <td>XLF</td>\n",
       "      <td>5876059.0</td>\n",
       "      <td>5449628.0</td>\n",
       "      <td>1.078250</td>\n",
       "      <td>NaN</td>\n",
       "      <td>NaN</td>\n",
       "      <td>6313668.0</td>\n",
       "      <td>7494806.0</td>\n",
       "      <td>0.457231</td>\n",
       "      <td>...</td>\n",
       "      <td>73596160.0</td>\n",
       "      <td>0.941696</td>\n",
       "      <td>-754707.0</td>\n",
       "      <td>0.842406</td>\n",
       "      <td>NaN</td>\n",
       "      <td>NaN</td>\n",
       "      <td>NaN</td>\n",
       "      <td>50.0</td>\n",
       "      <td>0.611560</td>\n",
       "      <td>NaN</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>3</th>\n",
       "      <td>2025-10-13</td>\n",
       "      <td>XLF</td>\n",
       "      <td>5662148.0</td>\n",
       "      <td>6372925.0</td>\n",
       "      <td>0.888469</td>\n",
       "      <td>NaN</td>\n",
       "      <td>NaN</td>\n",
       "      <td>3862869.0</td>\n",
       "      <td>3477345.0</td>\n",
       "      <td>0.526261</td>\n",
       "      <td>...</td>\n",
       "      <td>39651855.0</td>\n",
       "      <td>0.966980</td>\n",
       "      <td>-325253.0</td>\n",
       "      <td>1.110867</td>\n",
       "      <td>NaN</td>\n",
       "      <td>NaN</td>\n",
       "      <td>NaN</td>\n",
       "      <td>50.0</td>\n",
       "      <td>-0.962855</td>\n",
       "      <td>NaN</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>4</th>\n",
       "      <td>2025-10-14</td>\n",
       "      <td>XLF</td>\n",
       "      <td>8150311.0</td>\n",
       "      <td>5561366.0</td>\n",
       "      <td>1.465523</td>\n",
       "      <td>NaN</td>\n",
       "      <td>NaN</td>\n",
       "      <td>8209615.0</td>\n",
       "      <td>4177485.0</td>\n",
       "      <td>0.662755</td>\n",
       "      <td>...</td>\n",
       "      <td>62588716.0</td>\n",
       "      <td>1.679862</td>\n",
       "      <td>6621075.0</td>\n",
       "      <td>1.965205</td>\n",
       "      <td>1.886076</td>\n",
       "      <td>NaN</td>\n",
       "      <td>NaN</td>\n",
       "      <td>50.0</td>\n",
       "      <td>3.102910</td>\n",
       "      <td>69.526276</td>\n",
       "    </tr>\n",
       "  </tbody>\n",
       "</table>\n",
       "<p>5 rows × 29 columns</p>\n",
       "</div>"
      ],
      "text/plain": [
       "        date symbol  finra_buy_volume  short_sell_volume  \\\n",
       "0 2025-10-08    XLF         3449111.0          3193260.0   \n",
       "1 2025-10-09    XLF         4410866.0          4895667.0   \n",
       "2 2025-10-10    XLF         5876059.0          5449628.0   \n",
       "3 2025-10-13    XLF         5662148.0          6372925.0   \n",
       "4 2025-10-14    XLF         8150311.0          5561366.0   \n",
       "\n",
       "   short_buy_sell_ratio  short_buy_sell_ratio_z  finra_buy_volume_z  \\\n",
       "0              1.080122                     NaN                 NaN   \n",
       "1              0.900973                     NaN                 NaN   \n",
       "2              1.078250                     NaN                 NaN   \n",
       "3              0.888469                     NaN                 NaN   \n",
       "4              1.465523                     NaN                 NaN   \n",
       "\n",
       "   lit_buy_volume  lit_sell_volume  lit_buy_ratio  ...      volume  \\\n",
       "0       3239895.0        1640153.0       0.663906  ...  26848679.0   \n",
       "1       3608238.0        3521097.0       0.506111  ...  33922435.0   \n",
       "2       6313668.0        7494806.0       0.457231  ...  73596160.0   \n",
       "3       3862869.0        3477345.0       0.526261  ...  39651855.0   \n",
       "4       8209615.0        4177485.0       0.662755  ...  62588716.0   \n",
       "\n",
       "   combined_ratio    vw_flow  lit_buy_sell_ratio  vw_flow_z  acc_score_a  \\\n",
       "0        1.383909  1855593.0            1.975361        NaN          NaN   \n",
       "1        0.952754  -397660.0            1.024748        NaN          NaN   \n",
       "2        0.941696  -754707.0            0.842406        NaN          NaN   \n",
       "3        0.966980  -325253.0            1.110867        NaN          NaN   \n",
       "4        1.679862  6621075.0            1.965205   1.886076          NaN   \n",
       "\n",
       "   acc_score_b  acc_score_c  imbalance_signal  acc_score_d  \n",
       "0          NaN         50.0          0.605079          NaN  \n",
       "1          NaN         50.0         -0.835889          NaN  \n",
       "2          NaN         50.0          0.611560          NaN  \n",
       "3          NaN         50.0         -0.962855          NaN  \n",
       "4          NaN         50.0          3.102910    69.526276  \n",
       "\n",
       "[5 rows x 29 columns]"
      ]
     },
     "execution_count": 31,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "# Cell 3 - Data Loading and Processing\n",
    "query = '''\n",
    "    SELECT\n",
    "        date,\n",
    "        symbol,\n",
    "        finra_buy_volume,\n",
    "        short_sell_volume,\n",
    "        short_buy_sell_ratio,\n",
    "        short_buy_sell_ratio_z,\n",
    "        finra_buy_volume_z,\n",
    "        lit_buy_volume,\n",
    "        lit_sell_volume,\n",
    "        lit_buy_ratio,\n",
    "        lit_flow_imbalance,\n",
    "        lit_flow_imbalance_z,\n",
    "        return_z,\n",
    "        otc_participation_z,\n",
    "        confidence\n",
    "    FROM daily_metrics\n",
    "    WHERE symbol = ? AND date BETWEEN ? AND ?\n",
    "    ORDER BY date\n",
    "'''\n",
    "\n",
    "ohlc_query = '''\n",
    "    SELECT\n",
    "        trade_date AS date,\n",
    "        open,\n",
    "        high,\n",
    "        low,\n",
    "        close,\n",
    "        volume\n",
    "    FROM polygon_daily_agg_raw\n",
    "    WHERE symbol = ? AND trade_date BETWEEN ? AND ?\n",
    "    ORDER BY trade_date\n",
    "'''\n",
    "\n",
    "with duckdb.connect(str(DB_PATH)) as conn:\n",
    "    df = conn.execute(query, [TICKER.upper(), START_DATE, END_DATE]).df()\n",
    "    df_ohlc = conn.execute(ohlc_query, [TICKER.upper(), START_DATE, END_DATE]).df()\n",
    "\n",
    "if df.empty:\n",
    "    raise ValueError(f'No data found for {TICKER} between {START_DATE} and {END_DATE}.')\n",
    "\n",
    "df['date'] = pd.to_datetime(df['date'])\n",
    "numeric_cols = [\n",
    "    'finra_buy_volume',\n",
    "    'short_sell_volume',\n",
    "    'short_buy_sell_ratio',\n",
    "    'short_buy_sell_ratio_z',\n",
    "    'finra_buy_volume_z',\n",
    "    'lit_buy_volume',\n",
    "    'lit_sell_volume',\n",
    "    'lit_buy_ratio',\n",
    "    'lit_flow_imbalance',\n",
    "    'lit_flow_imbalance_z',\n",
    "    'return_z',\n",
    "    'otc_participation_z',\n",
    "    'confidence',\n",
    "]\n",
    "for col in numeric_cols:\n",
    "    if col in df.columns:\n",
    "        df[col] = pd.to_numeric(df[col], errors='coerce')\n",
    "\n",
    "# Process OHLC data\n",
    "if not df_ohlc.empty:\n",
    "    df_ohlc['date'] = pd.to_datetime(df_ohlc['date'])\n",
    "    for col in ['open', 'high', 'low', 'close', 'volume']:\n",
    "        if col in df_ohlc.columns:\n",
    "            df_ohlc[col] = pd.to_numeric(df_ohlc[col], errors='coerce')\n",
    "    # Merge OHLC with metrics on date\n",
    "    df = df.merge(df_ohlc, on='date', how='left')\n",
    "else:\n",
    "    df['open'] = np.nan\n",
    "    df['high'] = np.nan\n",
    "    df['low'] = np.nan\n",
    "    df['close'] = np.nan\n",
    "    df['volume'] = np.nan\n",
    "\n",
    "# Use finra_buy_volume directly (was: short_buy_volume)\n",
    "short_buy = df['finra_buy_volume'].fillna(0.0)\n",
    "short_sell = df['short_sell_volume'].fillna(0.0)\n",
    "lit_buy = df['lit_buy_volume'].fillna(0.0)\n",
    "lit_sell = df['lit_sell_volume'].fillna(0.0)\n",
    "total_buy = short_buy + lit_buy\n",
    "total_sell = short_sell + lit_sell\n",
    "\n",
    "# Compute combined ratio\n",
    "df['combined_ratio'] = np.nan\n",
    "valid_ratio = total_sell > 0\n",
    "df.loc[valid_ratio, 'combined_ratio'] = total_buy[valid_ratio] / total_sell[valid_ratio]\n",
    "df['combined_ratio'] = pd.to_numeric(df['combined_ratio'], errors='coerce')\n",
    "\n",
    "# Compute VW flow\n",
    "df['vw_flow'] = np.nan\n",
    "has_flow = (short_buy > 0) | (short_sell > 0) | (lit_buy > 0) | (lit_sell > 0)\n",
    "df.loc[has_flow, 'vw_flow'] = total_buy[has_flow] - total_sell[has_flow]\n",
    "df['vw_flow'] = pd.to_numeric(df['vw_flow'], errors='coerce')\n",
    "\n",
    "# Compute Lit Buy/Sell Ratio (NEW for Panel 3)\n",
    "df['lit_buy_sell_ratio'] = np.nan\n",
    "valid_lit = lit_sell > 0\n",
    "df.loc[valid_lit, 'lit_buy_sell_ratio'] = lit_buy[valid_lit] / lit_sell[valid_lit]\n",
    "df['lit_buy_sell_ratio'] = df['lit_buy_sell_ratio'].replace([np.inf, -np.inf], np.nan)\n",
    "\n",
    "# Fallback: compute short_buy_sell_ratio if missing\n",
    "if df['short_buy_sell_ratio'].isna().all():\n",
    "    valid = df['short_sell_volume'] > 0\n",
    "    df.loc[valid, 'short_buy_sell_ratio'] = df.loc[valid, 'finra_buy_volume'] / df.loc[valid, 'short_sell_volume']\n",
    "\n",
    "# Fallback: compute short_buy_sell_ratio_z if missing\n",
    "if df['short_buy_sell_ratio_z'].isna().all():\n",
    "    df['short_buy_sell_ratio_z'] = _rolling_zscore(\n",
    "        df['short_buy_sell_ratio'], config.short_z_window, config.zscore_min_periods\n",
    "    )\n",
    "\n",
    "# Fallback: compute finra_buy_volume_z if missing\n",
    "if df['finra_buy_volume_z'].isna().all():\n",
    "    df['finra_buy_volume_z'] = _rolling_zscore(\n",
    "        df['finra_buy_volume'], config.short_z_window, config.zscore_min_periods\n",
    "    )\n",
    "\n",
    "# Compute VW flow z-score\n",
    "df['vw_flow_z'] = _rolling_zscore(df['vw_flow'], config.short_z_window, config.zscore_min_periods)\n",
    "\n",
    "# Get lit z-score (with fallback)\n",
    "lit_z = df['lit_flow_imbalance_z'].copy()\n",
    "if lit_z.isna().all():\n",
    "    lit_z = _rolling_zscore(df['lit_flow_imbalance'], config.short_z_window, config.zscore_min_periods)\n",
    "\n",
    "price_z = df['return_z'].fillna(0.0)\n",
    "otc_z = df['otc_participation_z'].fillna(0.0)\n",
    "\n",
    "# =============================================================================\n",
    "# EXPERIMENT SCORES (A, B, C, D)\n",
    "# =============================================================================\n",
    "\n",
    "# Experiment A: VWBR-Anchored (finra_buy_volume_z)\n",
    "df['acc_score_a'] = _compute_score_display(\n",
    "    df['finra_buy_volume_z'], lit_z, price_z, otc_z, config\n",
    ")\n",
    "\n",
    "# Experiment B: Short Buy/Sell Ratio (current production)\n",
    "df['acc_score_b'] = _compute_score_display(\n",
    "    df['short_buy_sell_ratio_z'], lit_z, price_z, otc_z, config\n",
    ")\n",
    "\n",
    "# Experiment C: Combined (50/50 blend of VWBR_z + Ratio_z)\n",
    "blended_z = 0.5 * df['finra_buy_volume_z'].fillna(0.0) + 0.5 * df['short_buy_sell_ratio_z'].fillna(0.0)\n",
    "df['acc_score_c'] = _compute_score_display(\n",
    "    blended_z, lit_z, price_z, otc_z, config\n",
    ")\n",
    "\n",
    "# Experiment D: Exploratory (Imbalance-Weighted)\n",
    "B = df['finra_buy_volume'].fillna(0)\n",
    "S = df['short_sell_volume'].fillna(0)\n",
    "total = B + S\n",
    "imbalance = np.where(total > 0, (B - S) / total, 0)\n",
    "imbalance_signal = imbalance * np.log1p(total)\n",
    "df['imbalance_signal'] = imbalance_signal\n",
    "imbalance_z = _rolling_zscore(pd.Series(imbalance_signal, index=df.index), config.short_z_window, config.zscore_min_periods)\n",
    "df['acc_score_d'] = _compute_score_display(\n",
    "    imbalance_z, lit_z, price_z, otc_z, config\n",
    ")\n",
    "\n",
    "df['confidence'] = df['confidence'].fillna(0.5)\n",
    "print(f\"Loaded {len(df)} rows for {TICKER}\")\n",
    "df.head()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "a945e64d",
   "metadata": {},
   "outputs": [],
   "source": "# Cell 4 - Main Visualization (10-Panel Chart with OHLC)\nfrom matplotlib.lines import Line2D\nfrom matplotlib.patches import Patch, Rectangle\nfrom matplotlib.colors import LinearSegmentedColormap\n\nplt.style.use('dark_background')\nfig, axes = plt.subplots(\n    10,\n    1,\n    figsize=(16, 32),\n    sharex=True,\n    gridspec_kw={'height_ratios': [3.5, 2.5, 2.0, 2.0, 2.0, 2.0, 2.0, 2.0, 2.0, 2.0]},\n)\nfig.patch.set_facecolor(COLORS['background'])\n\nx = np.arange(len(df))\nlabels = df['date'].dt.strftime('%y-%m-%d').tolist()\n\n# Panel 0: OHLC Price Chart with Multi-Experiment Signal Markers\nax = axes[0]\n_apply_axis_style(ax)\n_plot_ohlc_bars(ax, df, x)\n\n# Calculate y-axis range and signal marker offset\ny_min = df['low'].min()\ny_max = df['high'].max()\nif pd.isna(y_min) or pd.isna(y_max):\n    y_min = df['close'].min()\n    y_max = df['close'].max()\ny_span = y_max - y_min if pd.notna(y_max) and pd.notna(y_min) else 0\nif not y_span or y_span <= 0:\n    y_span = float(df['close'].mean() or 1.0)\nbase_offset = y_span * 0.038  # Base vertical spacing between dot rows\n\n# Multi-experiment signal markers on OHLC - VERTICAL stacking\n# Colors are read from EXPERIMENT_DOT_COLORS in Cell 1\nOHLC_SIGNAL_SPECS = [\n    {'score': 'acc_score_a', 'label': 'A: VWBR', 'exp_key': 'A', 'y_level': 1},\n    {'score': 'acc_score_b', 'label': 'B: Ratio', 'exp_key': 'B', 'y_level': 2},\n    {'score': 'acc_score_c', 'label': 'C: Combined', 'exp_key': 'C', 'y_level': 3},\n    {'score': 'acc_score_d', 'label': 'D: Imbalance', 'exp_key': 'D', 'y_level': 4},\n]\n\nlegend_handles_ohlc = []\n\n# Handle OHLC_DOT_DISPLAY setting\nif OHLC_DOT_DISPLAY.upper() == 'NONE':\n    # No dots displayed - just show OHLC bars\n    pass\n\nelif OHLC_DOT_DISPLAY.upper() == 'MEAN':\n    # Mean mode: show single dot if 3+ experiments agree on direction\n    # Accumulation: 3+ scores >= 70, Distribution: 3+ scores <= 30\n    scores_a = df['acc_score_a'].fillna(50)\n    scores_b = df['acc_score_b'].fillna(50)\n    scores_c = df['acc_score_c'].fillna(50)\n    scores_d = df['acc_score_d'].fillna(50)\n    \n    # Count how many experiments signal accumulation/distribution per bar\n    accum_count = ((scores_a >= 70).astype(int) + (scores_b >= 70).astype(int) + \n                   (scores_c >= 70).astype(int) + (scores_d >= 70).astype(int))\n    dist_count = ((scores_a <= 30).astype(int) + (scores_b <= 30).astype(int) + \n                  (scores_c <= 30).astype(int) + (scores_d <= 30).astype(int))\n    \n    # Consensus masks: 3 or more experiments agree\n    buy_consensus = (accum_count >= 3).to_numpy()\n    sell_consensus = (dist_count >= 3).to_numpy()\n    \n    # Get colors from central config\n    mean_colors = EXPERIMENT_DOT_COLORS['Mean']\n    buy_color = mean_colors['buy']\n    sell_color = mean_colors['sell']\n    \n    y_off = base_offset * 1.5  # Single row, slightly larger offset\n    \n    if buy_consensus.any():\n        ax.scatter(\n            x[buy_consensus],\n            df.loc[buy_consensus, 'low'] - y_off,\n            s=SIGNAL_MARKER_SIZE,\n            c=buy_color,\n            edgecolors='none',\n            linewidths=0,\n            zorder=6,\n            alpha=0.95,\n        )\n    \n    if sell_consensus.any():\n        ax.scatter(\n            x[sell_consensus],\n            df.loc[sell_consensus, 'high'] + y_off,\n            s=SIGNAL_MARKER_SIZE,\n            c=sell_color,\n            edgecolors='none',\n            linewidths=0,\n            zorder=6,\n            alpha=0.95,\n        )\n    \n    # Legend for Mean mode\n    legend_handles_ohlc.append(\n        Line2D([0], [0], marker='o', color='none', markerfacecolor=buy_color,\n               markeredgecolor='none', markersize=7, label='Mean (3+ agree)')\n    )\n\nelif OHLC_DOT_DISPLAY.upper() in ['A', 'B', 'C', 'D']:\n    # Single experiment mode - show only that experiment's dots\n    exp_key = OHLC_DOT_DISPLAY.upper()\n    spec = next(s for s in OHLC_SIGNAL_SPECS if s['exp_key'] == exp_key)\n    \n    scores = df[spec['score']]\n    if not scores.isna().all():\n        buy_mask = (scores >= 70).to_numpy()\n        sell_mask = (scores <= 30).to_numpy()\n        \n        # Get colors from central config\n        exp_colors = EXPERIMENT_DOT_COLORS[exp_key]\n        buy_color = exp_colors['buy']\n        sell_color = exp_colors['sell']\n        \n        y_off = base_offset * 1.5  # Single row, slightly larger offset\n        \n        if buy_mask.any():\n            ax.scatter(\n                x[buy_mask],\n                df.loc[buy_mask, 'low'] - y_off,\n                s=SIGNAL_MARKER_SIZE,\n                c=buy_color,\n                edgecolors='none',\n                linewidths=0,\n                zorder=6,\n                alpha=0.9,\n            )\n        \n        if sell_mask.any():\n            ax.scatter(\n                x[sell_mask],\n                df.loc[sell_mask, 'high'] + y_off,\n                s=SIGNAL_MARKER_SIZE,\n                c=sell_color,\n                edgecolors='none',\n                linewidths=0,\n                zorder=6,\n                alpha=0.9,\n            )\n        \n        # Legend entry\n        legend_handles_ohlc.append(\n            Line2D([0], [0], marker='o', color='none', markerfacecolor=buy_color,\n                   markeredgecolor='none', markersize=6, label=spec['label'])\n        )\n\nelse:\n    # 'ALL' mode (default) - show all 4 experiments stacked vertically\n    for spec in OHLC_SIGNAL_SPECS:\n        scores = df[spec['score']]\n        if scores.isna().all():\n            continue\n        \n        y_off = base_offset * spec['y_level']  # Vertical offset based on level\n        buy_mask = (scores >= 70).to_numpy()\n        sell_mask = (scores <= 30).to_numpy()\n        \n        # Get colors from central config\n        exp_colors = EXPERIMENT_DOT_COLORS[spec['exp_key']]\n        buy_color = exp_colors['buy']\n        sell_color = exp_colors['sell']\n        \n        # Plot buy signals (below low) - stacked vertically\n        if buy_mask.any():\n            ax.scatter(\n                x[buy_mask],\n                df.loc[buy_mask, 'low'] - y_off,\n                s=SIGNAL_MARKER_SIZE - 15,\n                c=buy_color,\n                edgecolors='none',\n                linewidths=0,\n                zorder=6,\n                alpha=0.9,\n            )\n        \n        # Plot sell signals (above high) - stacked vertically\n        if sell_mask.any():\n            ax.scatter(\n                x[sell_mask],\n                df.loc[sell_mask, 'high'] + y_off,\n                s=SIGNAL_MARKER_SIZE - 15,\n                c=sell_color,\n                edgecolors='none',\n                linewidths=0,\n                zorder=6,\n                alpha=0.9,\n            )\n        \n        # Build legend entry\n        legend_handles_ohlc.append(\n            Line2D([0], [0], marker='o', color='none', markerfacecolor=buy_color,\n                   markeredgecolor='none', markersize=6, label=spec['label'])\n        )\n\n# Expand y-axis to fit all stacked dots\nax.set_ylim(y_min - base_offset * 5, y_max + base_offset * 5)\nax.set_ylabel('Price', color=COLORS['white'], fontsize=10)\nax.set_title(f'{TICKER} Price Action (Daily)', color=COLORS['white'], fontsize=11, fontweight='bold', loc='left')\n\n# Dynamic subtitle based on display mode\nif OHLC_DOT_DISPLAY.upper() == 'NONE':\n    subtitle = 'OHLC | Dots: disabled'\nelif OHLC_DOT_DISPLAY.upper() == 'MEAN':\n    subtitle = 'OHLC | Dots: Mean consensus (3+ experiments agree)'\nelif OHLC_DOT_DISPLAY.upper() in ['A', 'B', 'C', 'D']:\n    subtitle = f'OHLC | Dots: Score {OHLC_DOT_DISPLAY.upper()} only | below=Buy(≥70), above=Sell(≤30)'\nelse:\n    subtitle = 'OHLC | Dots: below=Buy(≥70), above=Sell(≤30) | Vertical stack: A→D'\nax.text(0.01, 0.92, subtitle, transform=ax.transAxes, fontsize=8, color=COLORS['text'], va='top')\n\n# Add legend for OHLC panel (if we have handles)\nif legend_handles_ohlc:\n    legend = ax.legend(\n        handles=legend_handles_ohlc,\n        loc='upper left',\n        fontsize=7,\n        frameon=True,\n        facecolor=COLORS['background'],\n        framealpha=0.7,\n        edgecolor=COLORS['grid'],\n        ncol=2,\n    )\n    for text in legend.get_texts():\n        text.set_color(COLORS['text'])\n\n\n# Panel 1: Agreement Heatmap (moved here, right after OHLC)\nax = axes[1]\nax.set_facecolor(COLORS['panel_bg'])\nax.tick_params(colors=COLORS['text'], labelsize=9)\nfor spine in ax.spines.values():\n    spine.set_visible(False)\n\n# Build score matrix: rows = experiments, cols = days\nscores_matrix = np.array([\n    df['acc_score_a'].values,\n    df['acc_score_b'].values,\n    df['acc_score_c'].values,\n    df['acc_score_d'].values,\n])\n\n# Color mapping function\ndef get_cell_color(score):\n    if pd.isna(score):\n        return COLORS['neutral']\n    if score >= 70:\n        return COLORS['green']\n    if score <= 30:\n        return COLORS['purple']\n    return '#555555'  # Grey for neutral\n\n# Draw heatmap cells\nrow_labels = ['A: VWBR', 'B: Short B/S', 'C: Combined', 'D: Imbalance']\ncell_height = 0.18\ny_start = 0.85\n\nfor row_idx, label in enumerate(row_labels):\n    y_pos = y_start - row_idx * (cell_height + 0.02)\n    \n    # Row label\n    ax.text(-0.8, y_pos + cell_height/2, label, ha='right', va='center',\n            fontsize=8, color=COLORS['text'], fontweight='bold')\n    \n    # Draw cells for each day\n    for col_idx in range(len(df)):\n        score = scores_matrix[row_idx, col_idx]\n        color = get_cell_color(score)\n        rect = Rectangle((col_idx - 0.4, y_pos), 0.8, cell_height,\n                         facecolor=color, edgecolor=COLORS['grid'], linewidth=0.3, alpha=0.85)\n        ax.add_patch(rect)\n\n# Highlight columns where 3+ scores agree on direction\nfor col_idx in range(len(df)):\n    col_scores = scores_matrix[:, col_idx]\n    accum_count = np.sum(col_scores >= 70)\n    dist_count = np.sum(col_scores <= 30)\n    \n    if accum_count >= 3:\n        # Strong accumulation agreement - green border\n        rect = Rectangle((col_idx - 0.45, y_start - 3*(cell_height+0.02) - 0.02), \n                         0.9, 4*(cell_height+0.02),\n                         facecolor='none', edgecolor=COLORS['green'], linewidth=2, alpha=0.8)\n        ax.add_patch(rect)\n    elif dist_count >= 3:\n        # Strong distribution agreement - red border\n        rect = Rectangle((col_idx - 0.45, y_start - 3*(cell_height+0.02) - 0.02), \n                         0.9, 4*(cell_height+0.02),\n                         facecolor='none', edgecolor=COLORS['red'], linewidth=2, alpha=0.8)\n        ax.add_patch(rect)\n\nax.set_xlim(-1.5, len(df))\nax.set_ylim(0, 1.0)\nax.set_title('Score Agreement Heatmap (≥3 = highlighted border)', color=COLORS['text'], fontsize=10, fontweight='bold', loc='left')\n\n\n# Panel 2: FINRA Buy Volume (B)\nax = axes[2]\n_apply_axis_style(ax)\nseries = df['finra_buy_volume']\nmask = series.notna()\n_plot_smooth_line(ax, x, series, COLORS['cyan'], mask, linewidth=MAIN_LINE_WIDTH)\nax.scatter(x[mask], series[mask], color=COLORS['cyan'], s=MARKER_SIZE, edgecolors=COLORS['white'], linewidths=0.4, zorder=5)\n_set_volume_axis(ax, series)\n_add_median_thresholds(ax, series, k=THRESHOLD_K)\nseries_mean = series.mean(skipna=True)\nif not pd.isna(series_mean):\n    ax.axhline(y=series_mean, color=COLORS['orange'], linestyle='--', linewidth=1.0, alpha=0.8, zorder=2)\n    ax.text(0.99, series_mean, f'mean: {_format_volume(series_mean)}', transform=ax.get_yaxis_transform(), ha='right', va='bottom', fontsize=7, color=COLORS['orange'])\nax.set_ylabel('FINRA Buy', color=COLORS['text'])\nax.set_title('FINRA Buy Volume', color=COLORS['text'], fontsize=10, fontweight='bold', loc='left')\nax.text(0.01, 0.92, 'finra_buy_volume (anchor for Score A)', transform=ax.transAxes, fontsize=8, color=COLORS['text'], va='top')\n\n\n# Panel 3: Short Buy/Sell Ratio\nax = axes[3]\n_apply_axis_style(ax)\nseries = df['short_buy_sell_ratio']\nmask = series.notna()\n_plot_smooth_line(ax, x, series, COLORS['cyan'], mask, linewidth=MAIN_LINE_WIDTH)\nax.scatter(x[mask], series[mask], color=COLORS['cyan'], s=MARKER_SIZE, edgecolors=COLORS['white'], linewidths=0.4, zorder=5)\n_set_ratio_axis(ax, series)\nax.axhline(1.0, color=COLORS['neutral'], linestyle='--', linewidth=1.0, alpha=0.7)\n_add_median_thresholds(ax, series, k=THRESHOLD_K)\nseries_mean = series.mean(skipna=True)\nif not pd.isna(series_mean):\n    ax.axhline(y=series_mean, color=COLORS['orange'], linestyle='--', linewidth=1.0, alpha=0.8, zorder=2)\n    ax.text(0.99, series_mean, f'mean: {series_mean:.2f}', transform=ax.get_yaxis_transform(), ha='right', va='bottom', fontsize=7, color=COLORS['orange'])\nax.set_ylabel('Short B/S', color=COLORS['text'])\nax.set_title('Short Buy/Sell Ratio', color=COLORS['text'], fontsize=10, fontweight='bold', loc='left')\nax.text(0.01, 0.92, 'short_buy_sell_ratio = finra_buy / short_sell (anchor for Score B)', transform=ax.transAxes, fontsize=8, color=COLORS['text'], va='top')\n\n\n# Panel 4: Lit Buy/Sell Ratio\nax = axes[4]\n_apply_axis_style(ax)\nseries = df['lit_buy_sell_ratio']\nmask = series.notna()\n_plot_smooth_line(ax, x, series, COLORS['cyan'], mask, linewidth=MAIN_LINE_WIDTH)\nax.scatter(x[mask], series[mask], color=COLORS['cyan'], s=MARKER_SIZE, edgecolors=COLORS['white'], linewidths=0.4, zorder=5)\n_set_ratio_axis(ax, series)\nax.axhline(1.0, color=COLORS['neutral'], linestyle='--', linewidth=1.0, alpha=0.7)\n_add_median_thresholds(ax, series, k=THRESHOLD_K)\nseries_mean = series.mean(skipna=True)\nif not pd.isna(series_mean):\n    ax.axhline(y=series_mean, color=COLORS['orange'], linestyle='--', linewidth=1.0, alpha=0.8, zorder=2)\n    ax.text(0.99, series_mean, f'mean: {series_mean:.2f}', transform=ax.get_yaxis_transform(), ha='right', va='bottom', fontsize=7, color=COLORS['orange'])\nax.set_ylabel('Lit B/S', color=COLORS['text'])\nax.set_title('Lit Market Buy/Sell Ratio', color=COLORS['text'], fontsize=10, fontweight='bold', loc='left')\nax.text(0.01, 0.92, 'lit_buy_sell_ratio = lit_buy_volume / lit_sell_volume', transform=ax.transAxes, fontsize=8, color=COLORS['text'], va='top')\n\n\n# Panel 5: Imbalance Signal (for Score D)\nax = axes[5]\n_apply_axis_style(ax)\nseries = df['imbalance_signal']\nmask = series.notna()\n_plot_smooth_line(ax, x, series, COLORS['cyan'], mask, linewidth=MAIN_LINE_WIDTH)\nax.scatter(x[mask], series[mask], color=COLORS['cyan'], s=MARKER_SIZE - 5, edgecolors=COLORS['white'], linewidths=0.4, zorder=5)\nax.axhline(0.0, color=COLORS['neutral'], linestyle='--', linewidth=1.2, alpha=0.7)\n_add_median_thresholds(ax, series, k=THRESHOLD_K, center_override=0.0)\nseries_mean = series.mean(skipna=True)\nif not pd.isna(series_mean):\n    ax.axhline(y=series_mean, color=COLORS['orange'], linestyle='--', linewidth=1.0, alpha=0.8, zorder=2)\n    ax.text(0.99, series_mean, f'mean: {series_mean:.2f}', transform=ax.get_yaxis_transform(), ha='right', va='bottom', fontsize=7, color=COLORS['orange'])\nax.set_ylabel('Signal', color=COLORS['text'])\nax.set_title('Imbalance × log1p(Volume)', color=COLORS['text'], fontsize=10, fontweight='bold', loc='left')\nax.text(0.01, 0.92, 'imbalance = (B-S)/(B+S), signal = imbalance × log1p(B+S) (anchor for Score D)', transform=ax.transAxes, fontsize=7, color=COLORS['text'], va='top')\n\n\n# Shared dot sources for all score panels\ndot_sources = {\n    'current': df['acc_score_b'],  # Use Score B as \"current\" reference\n    'option_a': df['acc_score_a'],\n    'option_b': df['acc_score_c'],\n}\n\n# Panel 6: Score A - VWBR (finra_buy_volume_z)\nax = axes[6]\nax.set_facecolor(COLORS['panel_bg'])\nax.tick_params(colors=COLORS['text'], labelsize=9)\nfor spine in ax.spines.values():\n    spine.set_visible(False)\n_plot_score_panel(ax, x, df['acc_score_a'], df['confidence'], 'Score A: VWBR-Anchored', DOT_MODE, dot_sources, \n                  force_self_dots=True, \n                  dot_accum_color=EXPERIMENT_DOT_COLORS['A']['buy'], \n                  dot_dist_color=EXPERIMENT_DOT_COLORS['A']['sell'])\nax.text(0.01, 0.92, 'short_z = finra_buy_volume_z\\nDetects: Large institutional buying regardless of sell-side', transform=ax.transAxes, fontsize=7, color=COLORS['text'], va='top')\n\n\n# Panel 7: Score B - Short Buy/Sell Ratio (Production Baseline)\nax = axes[7]\nax.set_facecolor(COLORS['panel_bg'])\nax.tick_params(colors=COLORS['text'], labelsize=9)\nfor spine in ax.spines.values():\n    spine.set_visible(False)\n_plot_score_panel(ax, x, df['acc_score_b'], df['confidence'], 'Score B: Short B/S Ratio (Baseline)', DOT_MODE, dot_sources, \n                  force_self_dots=True, \n                  dot_accum_color=EXPERIMENT_DOT_COLORS['B']['buy'], \n                  dot_dist_color=EXPERIMENT_DOT_COLORS['B']['sell'])\nax.text(0.01, 0.92, 'short_z = short_buy_sell_ratio_z\\nDetects: Directional bias independent of absolute volume', transform=ax.transAxes, fontsize=7, color=COLORS['text'], va='top')\n\n\n# Panel 8: Score C - Combined (50/50 Blend)\nax = axes[8]\nax.set_facecolor(COLORS['panel_bg'])\nax.tick_params(colors=COLORS['text'], labelsize=9)\nfor spine in ax.spines.values():\n    spine.set_visible(False)\n_plot_score_panel(ax, x, df['acc_score_c'], df['confidence'], 'Score C: Combined (50/50)', DOT_MODE, dot_sources, \n                  force_self_dots=True, \n                  dot_accum_color=EXPERIMENT_DOT_COLORS['C']['buy'], \n                  dot_dist_color=EXPERIMENT_DOT_COLORS['C']['sell'])\nax.text(0.01, 0.92, 'short_z = 0.5×VWBR_z + 0.5×Ratio_z\\nDetects: High-confidence (volume + direction aligned)', transform=ax.transAxes, fontsize=7, color=COLORS['text'], va='top')\n\n\n# Panel 9: Score D - Exploratory (Imbalance-Weighted)\nax = axes[9]\nax.set_facecolor(COLORS['panel_bg'])\nax.tick_params(colors=COLORS['text'], labelsize=9)\nfor spine in ax.spines.values():\n    spine.set_visible(False)\n_plot_score_panel(ax, x, df['acc_score_d'], df['confidence'], 'Score D: Imbalance-Weighted', DOT_MODE, dot_sources, \n                  force_self_dots=True, \n                  dot_accum_color=EXPERIMENT_DOT_COLORS['D']['buy'], \n                  dot_dist_color=EXPERIMENT_DOT_COLORS['D']['sell'])\nax.text(0.01, 0.92, 'short_z = zscore(imbalance × log1p(B+S))\\nDetects: Conviction signal (direction × volume magnitude)', transform=ax.transAxes, fontsize=7, color=COLORS['text'], va='top')\n\n\n# Set x-axis labels\naxes[-1].set_xticks(x)\naxes[-1].set_xticklabels(labels, rotation=45, ha='right', fontsize=8)\n\nfig.suptitle(f'{TICKER} - Accumulation Signal Sandbox (4 Experiments)', color=COLORS['text'], fontsize=14, fontweight='bold')\nplt.tight_layout(rect=[0, 0, 1, 0.97])\nplt.show()"
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "base",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.12.7"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 5
}